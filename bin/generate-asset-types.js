#!/usr/bin/env node

/*
 * Generates .d.ts files for all of our assets to provide stricter type
 * checking and nicer autocomplete when importing them.
 */

async function main() {
  const camelcase = (await import("camelcase")).default;
  const fs = await import("fs");
  const { globSync } = await import("glob");
  const path = await import("path");
  const yargs = require("yargs");
  const chokidar = await import("chokidar");

  // mapping extensions to their variable prefix
  const extensionToPrefix = {
    // images
    bmp: "img",
    gif: "img",
    jpg: "img",
    png: "img",
    svg: "img",
    // fonts
    ttf: "fnt",
    otf: "fnt",
    woff: "fnt",
    woff2: "fnt",
    // audio
    flac: "snd",
    mp3: "snd",
    ogg: "snd",
    wav: "snd",
    // shaders
    frag: "frag",
    vert: "vert",
    //models
    gltf: "gltf",
    glb: "glb",
    //misc
    txt: "txt",
  };

  const extensions = Object.keys(extensionToPrefix);
  const extensionPattern = extensions.join("|");

  // The contents of the generated file
  function getContent(fileName) {
    const parts = path.basename(fileName).split(".");
    const baseVarName = camelcase(parts[0]);

    // the extension before the .d.ts
    const extension = parts.length > 3 ? parts[parts.length - 3] : "";
    const prefix = getVariablePrefixFromExtension(extension);

    const varName = `${prefix}_${baseVarName}`;

    return [
      `// This file autogenerated by generate-asset-types.js`,
      `declare const ${varName}: string;`,
      `export default ${varName};`,
    ].join("\n");
  }

  function getVariablePrefixFromExtension(extension) {
    if (extension in extensionToPrefix) {
      return extensionToPrefix[extension];
    } else {
      console.log("unknown extension", extension);
      return "res";
    }
  }

  // Removes old types
  function cleanTypes(assetsFolder, silent = false) {
    if (!silent) {
      console.log(
        `removing old asset .d.ts files from "${assetsFolder}" . . .`
      );
    }
    const pattern = `${assetsFolder}/**/*.@(${extensionPattern}).d.ts`;
    const fileNames = globSync(pattern, {});
    fileNames.forEach((fileName) => {
      if (!silent) {
        console.log(" - removed " + fileName);
      }
      fs.unlinkSync(fileName);
    });
    if (fileNames.length === 0 && !silent) {
      console.log("No files to remove");
    }
    return fileNames;
  }

  // Generates the new type files
  function generateTypes(assetsFolder, silent = false) {
    if (!silent) {
      console.log(
        `generating new asset .d.ts files in "${assetsFolder}" . . .`
      );
    }
    const pattern = `${assetsFolder}/**/*.@(${extensionPattern})`;
    const fileNames = globSync(pattern, {}).map((f) => f + ".d.ts");
    fileNames.forEach((fileName) => {
      fs.writeFileSync(fileName, getContent(fileName));
      if (!silent) {
        console.log(" - created " + fileName);
      }
    });
    if (fileNames.length === 0 && !silent) {
      console.log("No files to generate");
    }

    generateManifest(assetsFolder, silent);

    return fileNames;
  }

  function generateManifest(assetsFolder, silent = false) {
    const pattern = `${assetsFolder}/**/*.@(${extensionPattern})`;
    const fileNames = globSync(pattern, {}).map((f) => f);

    const soundFiles = [];
    const imageFiles = [];
    const fontFiles = [];

    for (const fileName of fileNames) {
      const parts = fileName.split(".");
      const extension = parts.length > 1 ? parts[parts.length - 1] : "";
      const prefix = getVariablePrefixFromExtension(extension);

      const relativePath = `./${path.relative(assetsFolder, fileName)}`;

      switch (prefix) {
        case "snd":
          soundFiles.push(relativePath);
          break;
        case "img":
          imageFiles.push(relativePath);
          break;
        case "fnt":
          fontFiles.push(relativePath);
          break;
      }
    }
    const varName = (filename) =>
      camelcase(path.basename(filename).split(".")[0]);

    const lines = [];
    lines.push("// This file autogenerated by generate-asset-types.js");
    lines.push("const sounds = {");
    for (const sound of soundFiles) {
      lines.push(`  ${varName(sound)}: require("${sound}"),`);
    }
    lines.push("};");
    lines.push("export type SoundName = keyof typeof sounds;");
    lines.push("");

    lines.push("const images = {");
    for (const image of imageFiles) {
      lines.push(`  ${varName(image)}: require("${image}"),`);
    }
    lines.push("};");
    lines.push("export type ImageName = keyof typeof images;");
    lines.push("");

    lines.push("const fonts = {");
    for (const font of fontFiles) {
      lines.push(`  ${varName(font)}: require("${font}"),`);
    }
    lines.push("};");
    lines.push("export type FontName = keyof typeof fonts;");
    lines.push("");

    // lines.push("type ResourceManifest = {");
    // lines.push("  images: Record<string, string>;");
    // lines.push("  sounds: Record<string, string>;");
    // lines.push("  fonts: ReadonlyArray<string>;");
    // lines.push("}");

    lines.push("export const RESOURCES = { sounds, images, fonts }; ");

    const manifestFile = `${assetsFolder}/resources.ts`;
    fs.writeFileSync(manifestFile, lines.join("\n"));

    if (!silent) {
      console.log(`manifest at ${manifestFile}`);
    }
  }

  function cleanAndGenerate(assetsFolder) {
    const removed = new Set(cleanTypes(assetsFolder, true));
    const generated = new Set(generateTypes(assetsFolder, true));
    const newFiles = [];
    const deletedFiles = [];
    for (const fileName of removed) {
      if (!generated.has(fileName)) {
        deletedFiles.push(fileName);
      }
    }
    for (const fileName of generated) {
      if (!removed.has(fileName)) {
        newFiles.push(fileName);
      }
    }
    if (deletedFiles.length) {
      console.log(deletedFiles.map((f) => ` - removed ${f}`).join("\n"));
    }
    if (newFiles.length) {
      console.log(newFiles.map((f) => ` + created ${f}`).join("\n"));
    }
    if (newFiles.length === 0 && deletedFiles.length === 0) {
      console.log("Nothing has changed");
    }
  }

  function watch(assetsFolder) {
    const resourceGlob = `${assetsFolder}/**/*.{${extensions.join(",")}}`;
    console.log(`Watching for resource changes in ${resourceGlob}`);

    // Run once at the beginning
    cleanAndGenerate(assetsFolder);

    // Then run it on every new or removed file
    chokidar
      .watch(resourceGlob, { ignoreInitial: true })
      .on("add", (path, stats) => {
        cleanAndGenerate(assetsFolder);
      })
      .on("unlink", (path, stats) => {
        cleanAndGenerate(assetsFolder);
      });
  }

  yargs(process.argv.slice(2))
    .scriptName("generate-asset-types")
    .usage(
      "Generates .d.ts files for assets to provide stricter type checking and nicer autocomplete when importing them."
    )
    .help()
    .option("directory", {
      alias: "d",
      describe: "Directory containing assets",
      default: "./src/assets",
      coerce: (d) => path.resolve(d),
      type: "string",
      normalize: true,
      global: true,
    })
    .command(
      "$0",
      "cleans and generates",
      () => {},
      (argv) => {
        console.log(`Updating asset types in "${assetsFolder}" . . .`);
        cleanAndGenerate(argv.directory);
      }
    )
    .command(
      "watch",
      "keeps everything up to date",
      () => {},
      (argv) => {
        watch(argv.directory);
      }
    )
    .command(
      "clean",
      "removes all asset types",
      () => {},
      (argv) => {
        cleanTypes(argv.directory);
      }
    )
    .command(
      "generate",
      "generates new .d.ts files",
      () => {},
      (argv) => {
        generateTypes(argv.directory);
      }
    ).argv;
}

main();
